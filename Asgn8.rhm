#lang rhombus

// Assignment 8

// Data Definitions

// ExprC type
class ExprC():
  nonfinal
// numC is a number
class NumC(n :~ Real):
  extends ExprC
// strC represents string literals
class StrC(s :~ String):
  extends ExprC
// ifC represents an if statement
class IfC(test :~ ExprC, then :~ ExprC, else :~ ExprC):
  extends ExprC
// appC represents a function application
class AppC(fun_expr :~ ExprC, args :~ List): // how to annotate list type?
  extends ExprC
// lamC represents an anonymous function
class LamC(args :~ List, body :~ ExprC):
  extends ExprC
class IdC(s :~ Symbol):
  extends ExprC





// Binding represents a bind of a name to a value
class Binding(name :~ Symbol, value)
// Environment represents a list of bindings and contains methods to lookup symbols for vars and extend the env
class Environment(bindings :~ List):
  // Lookup: looks up the symbol in the environment
  method lookup(s :~ Symbol):
    fun lookup_helper(binding_list :~ List):
      match binding_list
      | List.empty:
          error(~who: #'lookup, "AAQZ: name not found in lookup")
      | ~else:
          cond
          | s === List.first(binding_list).name:
              List.first(binding_list).value
          | ~else:
              lookup_helper(List.rest(binding_list))
    lookup_helper(bindings.copy().to_list())
            
  // Extend: helper to extend the current environment
  method extend(func_args :~ List, app_args :~ List):
    fun extend_helper(syms :~ List, vals :~ List):
      match List(syms, vals)
      | [List.empty, List.empty]:
          []
      | [!List.empty, !List.empty]:
          List.append([Binding(List.first(syms), List.first(vals))], extend_helper(List.rest(syms), List.rest(vals)))
      | ~else:
          error(~who: #'extend_helper, "AAQZ: How did we get here? num of args don't match")
    let new_bindings = extend_helper(func_args.copy().to_list(), app_args.copy().to_list())
    //print("new: ", new_bindings, "\n")
    //print("old: ", bindings, "\n")
    Environment(List.append(new_bindings, bindings))



    
// Value type, contains number, boolean, string, closure, primitive
class Value():
  nonfinal
// numV represents a number value
class NumV(n :~ Real):
  extends Value
// strV represents a string value
class StrV(s :~ String):
  extends Value
// boolV represents a boolean value
class BoolV(b :~ Boolean):
  extends Value
// closV represents a function as a value
class CloV(args :~ List, body :~ ExprC, env :~ Environment):
  extends Value
//  primV represents a primitive function
class PrimV(op :~ Symbol):
  extends Value

  // evaluate: Helper function to evaluate primitive functions
  method primV_evaluate(args :~ List):
    match op
    | #'#{+}:
        match args
        | List(NumV(l), NumV(r)):
            NumV(l+r)
        | _:
            error(~who: #'primV_evaluate, "AAQZ: wrong types for +")
    | #'#{-}:
        match args
        | List(NumV(l), NumV(r)):
            NumV(l-r)
        | _:
            error(~who: #'primV_evaluate, "AAQZ: wrong types for -")
    | #'#{*}:
        match args
        | List(NumV(l), NumV(r)):
            NumV(l*r)
        | _:
            error(~who: #'primV_evaluate, "AAQZ: wrong types for *")
    | #'#{/}:
        match args
        | List(NumV(l), NumV(r)):
            cond
            | r == 0:
                error(~who: #'primV_evaluate, "AAQZ: division by zero")
            | ~else:
                NumV(l/r)
        | _:
            error(~who: #'primV_evaluate, "AAQZ: wrong types for /")
    | #'#{<=}:
        match args
        | List(NumV(l), NumV(r)):
            BoolV(l <= r)
        | _:
            error(~who: #'primV_evaluate, "AAQZ: wrong types for <=")
    | #'#{equal?}:
        match args
        | List(NumV(l), NumV(r)):
            BoolV(l == r)
        | List(StrV(l), StrV(r)):
            BoolV(l == r)
        | List(BoolV(l), BoolV(r)):
            BoolV(l == r)
        | _:
            BoolV(#false)
    | #'seq:
        cond
        | args.length() == 0:
            error(~who: #'primV_evaluate, "AAQZ: seq requires at least one expression")
        | ~else:
            List.last(args)
    | #'println:
        match args
        | List(StrV(s)):
            println(s)
            BoolV(#true)
        | _:
            error(~who: #'primV_evaluate, "AAQZ: wrong type for println")
    // Documentation: https://docs.racket-lang.org/rhombus-reference/Input_Ports.html
    | #'#{read-num}:
        error(~who: #'primV_evaluate, "AAQZ: unimplemented")
    | #'#{read-str}:
        error(~who: #'primV_evaluate, "AAQZ: unimplemented")
    // Documentation: https://docs.racket-lang.org/rhombus-reference/Strings.html
    | #'#{++}:
        error(~who: #'primV_evaluate, "AAQZ: unimplemented")


// Top_env: creates top-level environment
def top_env = Environment(
  [
    Binding(#'true, BoolV(#true)),
    Binding(#'false, BoolV(#false)),
    Binding(Symbol.from_string("+"), PrimV(Symbol.from_string("+"))),
    Binding(Symbol.from_string("-"), PrimV(Symbol.from_string("-"))),
    Binding(Symbol.from_string("*"), PrimV(Symbol.from_string("*"))),
    Binding(Symbol.from_string("/"), PrimV(Symbol.from_string("/"))),
    Binding(Symbol.from_string("<="), PrimV(Symbol.from_string("<="))),
    Binding(Symbol.from_string("equal?"), PrimV(Symbol.from_string("equal?"))),
    Binding(#'println, PrimV(#'println)),
    Binding(Symbol.from_string("read-num"), PrimV(Symbol.from_string("read-num"))),
    Binding(Symbol.from_string("read-str"), PrimV(Symbol.from_string("read-str"))),
    Binding(#'seq, PrimV(#'seq)),
    Binding(Symbol.from_string("++"), PrimV(Symbol.from_string("++")))
  ])



// Interp: Interprets an expression into a value
fun interp(e :~ ExprC, env :~ Environment):
  //print(e, "\n")
  match e
  | NumC(n):
      NumV(n)
  | StrC(s):
      StrV(s)
  | IdC(#'error):
      error(~who: #'interp, "AAQZ: user error")
  | IdC(s):
      env.lookup(s)
  | IfC(test, then, else):
      match interp(test, env)
      | BoolV(b):
          cond
          | b:
              interp(then, env)
          | ~else:
              interp(else, env)
      | _:
          error(~who: #'interp, "AAQZ: wrong types for conditional test")
  | LamC(args, body):
      CloV(args, body, env)
  | AppC(f_expr, args):
      match interp(f_expr, env)
      | CloV(clos_args, body, clos_env):
          cond
          | clos_args.length() != args.length():
              error(~who: #'interp, "AAQZ: argument count mismatch")
          | ~else:
              //interp(body, env.extend(clos_args, List.map(args, (interp(_, env))), clos_env))
              //print("env: ", env, "\n")
              interp(body, env.extend(clos_args, List.map(args, (interp(_, env)))))
      | PrimV(op):
          PrimV(op).primV_evaluate(List.map(args, (interp(_, env))))
      | _:
          error(~who: #'interp, "AAQZ: function application did not receive valid operator")


//Parse: parse an expression and convert it into an AST
fun parse(sexp :~ Any): 
  match sexp
  | num :: Real: NumC(num)
  | str :: String: StrC(str)
  | sym :: Symbol: IdC(sym)
  | List(#'if , test, then, else):
      IfC(parse(test), parse(then), parse(else))
  | List(s, args, ...):
      AppC(parse(s), [parse(args), ...] )
  | List(args, ... , '=>' , body):
      LamC(checkDupe([checkType(args), ...]), parse(body))
  | other:
      error(~who: #'interp, "AAQZ: improper format")


//takes in an expression and return the interpreted value based on AAQZ5 syntax
fun topInterp(sexp :~ Any):
  serialize(interp(parse(sexp), top_env))

//helps check if an argument is a symbol, return error if not
fun checkType(maybeSym :~ Any):
  if maybeSym :: Symbol
  |  maybeSym
  |  error(~who: #'interp, "AAQZ: non symbol as argument name")

//takes in a list and see if duplicates existed in the list
fun checkDupe(args :~ List):
  match args
  | List(): List()
  | List.cons(first, rest): 
      List.cons(dupeHelper(first, rest), checkDupe(rest))

//helps parse through function arguments to see if newly
//added argument is a duplicate of existing ones
fun dupeHelper(new :~ Any, existing :~ List):
  match existing
  | List(): new
  | List.cons(first, rest):
      if new == first
      |  error(~who: #'interp, "AAQZ: duplicate argument")
      |  dupeHelper(new, rest)

//serialize a value into more readable format
fun serialize(v :~ Value):
  match v
  | CloV(a , b , c): "#<procedure>"
  | PrimV(a): "#<primop>"
  | NumV(n):
      n
  | StrV(s):
      "/" +& s +& "/"
  | BoolV(b):
      if b
      | "true"
      | "false"

// Test Cases

// Interp Functionality
check interp(NumC(4), top_env) ~is NumV(4)
check interp(StrC("hello"), top_env) ~is StrV("hello")
check interp(IdC(#'true), top_env) ~is BoolV(#true)
check interp(IdC(#'false), top_env) ~is BoolV(#false)
check interp(IfC(IdC(#'true), NumC(10), NumC(20)), top_env) ~is NumV(10)
check interp(IfC(IdC(#'false), NumC(10), NumC(20)), top_env) ~is NumV(20)
check interp(AppC(IdC((Symbol.from_string("+"))), List(NumC(6), NumC(2))), top_env) ~is NumV(8)
check interp(AppC(IdC(Symbol.from_string("-")), List(NumC(6), NumC(2))), top_env) ~is NumV(4)
check interp(AppC(IdC(Symbol.from_string("*")), List(NumC(6), NumC(2))), top_env) ~is NumV(12)
check interp(AppC(IdC(Symbol.from_string("/")), List(NumC(6), NumC(2))), top_env) ~is NumV(3)
check interp(AppC(IdC(Symbol.from_string("<=")), List(NumC(2), NumC(6))), top_env) ~is BoolV(#true)
check interp(AppC(IdC(Symbol.from_string("<=")), List(NumC(6), NumC(2))), top_env) ~is BoolV(#false)
check interp(AppC(IdC(Symbol.from_string("equal?")), List(NumC(2), NumC(2))), top_env) ~is BoolV(#true)
check interp(AppC(IdC(Symbol.from_string("equal?")), List(NumC(2), NumC(3))), top_env) ~is BoolV(#false)
check interp(AppC(IdC(Symbol.from_string("equal?")),
                  List(AppC(IdC(Symbol.from_string("<=")), List(NumC(6), NumC(2))),
                       AppC(IdC(Symbol.from_string("equal?")), List(NumC(10), StrC("thanks"))))), top_env) ~is BoolV(#true)
check interp(AppC(IdC(Symbol.from_string("equal?")), List(StrC("hello"), StrC("hello"))), top_env) ~is BoolV(#true)
check interp(AppC(IdC(Symbol.from_string("equal?")), List(StrC("hello"), StrC("world"))), top_env) ~is BoolV(#false)
check interp(AppC(IdC(Symbol.from_string("println")), List(StrC("hello"))), top_env) ~is BoolV(#true)
check interp(AppC(IdC(Symbol.from_string("println")), List(StrC("world"))), top_env) ~is BoolV(#true)
check interp(AppC(IdC(#'seq), List(NumC(1), NumC(2), NumC(3))), top_env) ~is NumV(3)


check interp(AppC(LamC(List(#'x, #'y), AppC(IdC(Symbol.from_string("+")), List(IdC(#'x), IdC(#'y)))), List(NumC(5), NumC(7))), top_env) ~is NumV(12)
check topInterp(List(Symbol.from_string("+"), 3, 4)) ~is 7
check topInterp(7) ~is 7
check topInterp("stuff") ~is "/stuff/"
check topInterp(Symbol.from_string("+")) ~is "#<primop>"
check topInterp(List(#'if,
                     List(Symbol.from_string("equal?"), List(Symbol.from_string("+"), 3, 4), 7), 
                     7, 
                     8)) ~is 7



// Interp Errors 
check:
  interp(IdC(#'error), top_env)
  ~throws "AAQZ: user error"
check:
  interp(IdC(#'undefined), top_env)
  ~throws "AAQZ: name not found in lookup"
check:
  interp(IfC(NumC(10), NumC(10), StrC("hello")), top_env)
  ~throws "AAQZ: wrong types for conditional test"
check:
  interp(AppC(LamC(List(#'x, #'y, #'z), NumC(430)), List(StrC("hello"), StrC("world"))), top_env)
  ~throws "AAQZ: argument count mismatch"
check:
  interp(AppC(NumC(5), List(StrC("world"))), top_env)
  ~throws "AAQZ: function application did not receive valid operator"
check:
  interp(AppC(IdC((Symbol.from_string("+"))), List(NumC(6), StrC("hello"))), top_env)
  ~throws: "AAQZ: wrong types for +"
check:
  interp(AppC(IdC((Symbol.from_string("-"))), List(NumC(6))), top_env)
  ~throws "AAQZ: wrong types for -"
check:
  interp(AppC(IdC((Symbol.from_string("*"))), List(NumC(6), NumC(1), NumC(2))), top_env)
  ~throws "AAQZ: wrong types for *"
check:
  interp(AppC(IdC((Symbol.from_string("/"))), List(StrC("yes"), NumC(6))), top_env)
  ~throws "AAQZ: wrong types for /"
check:
  interp(AppC(IdC((Symbol.from_string("/"))), List(NumC(6), NumC(0))), top_env)
  ~throws "AAQZ: division by zero"
check:
  interp(AppC(IdC(Symbol.from_string("<=")), List(NumC(2), StrC("hello"))), top_env)
  ~throws "AAQZ: wrong types for <="
check:
  interp(AppC(IdC(Symbol.from_string("<=")), List(NumC(4), NumC(5), NumC(6))), top_env)
  ~throws "AAQZ: wrong types for <="
check:
  interp(AppC(IdC(Symbol.from_string("println")), List(NumC(894))), top_env)
  ~throws "AAQZ: wrong type for println"
check:
  interp(AppC(IdC(#'seq), List()), top_env)
  ~throws "AAQZ: seq requires at least one expression"




 

                                                     


